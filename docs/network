The client will spawn a new thread to listen for the server updates.
On an update select() will return to fetch the data, deserialize it and install
it as the updated opponent position.

As the local game never touches the opponents position, we don't need a mutex
lock.

On each game event, the client will serialize its game struct and send it to
the server.

The server will accept and forward the connection to the client.

As network operations are asynchronous, and very slow, this will also happen in
a separate thread. Potentially the same as the listening thread, however.

The game_loop can serialize the game state, and write to a pipe. Which can
trigger the listener to read and send to the server.
